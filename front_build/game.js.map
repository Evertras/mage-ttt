{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./front/main.ts","webpack:///./node_modules/cachepuncher/index.js","webpack:///./node_modules/events.js/index.js","webpack:///./node_modules/inherits/inherits_browser.js","webpack:///./node_modules/mage-sdk-js.session/index.js","webpack:///./node_modules/mage-sdk-js/index.js","webpack:///./node_modules/mage-sdk-js/lib/CommandCenter/index.js","webpack:///./node_modules/mage-sdk-js/lib/EventManager.js","webpack:///./node_modules/mage-sdk-js/lib/HttpRequest.js","webpack:///./node_modules/mage-sdk-js/lib/Mage.js","webpack:///./node_modules/mage-sdk-js/lib/MsgServer.js","webpack:///./node_modules/mage-sdk-js/lib/messageStream/http.js","webpack:///./node_modules/mage-sdk-js/lib/messageStream/index.js","webpack:///./node_modules/mage-sdk-js/lib/messageStream/ws.js","webpack:///./node_modules/wizcorp-deep-copy.js/index.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,kDAA0C,gCAAgC;AAC1E;AACA;;AAEA;AACA;AACA;AACA,gEAAwD,kBAAkB;AAC1E;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iDAAyC,iCAAiC;AAC1E,wHAAgH,mBAAmB,EAAE;AACrI;AACA;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;;;AClFA,2FAAoC;AAEpC,IAAI,CAAC,WAAW,CAAC,uBAAuB,CAAC,CAAC;AAE1C,IAAK,KAIJ;AAJD,WAAK,KAAK;IACN,uCAAO;IACP,qCAAM;IACN,yCAAQ;AACZ,CAAC,EAJI,KAAK,KAAL,KAAK,QAIT;AAGD,SAAS,gBAAgB,CAAC,KAAY;IAClC,MAAM,GAAG,GAAG,CAAC,SAAS,EAAE,OAAO,EAAE,MAAM,CAAC,CAAC;IACzC,IAAI,MAAM,GAAW,EAAE,CAAC;IAExB,QAAQ,KAAK,EAAE;QACX,KAAK,KAAK,CAAC,OAAO;YACd,MAAM,GAAG,SAAS,CAAC;YACnB,MAAM;QAEV,KAAK,KAAK,CAAC,MAAM;YACb,MAAM,GAAG,OAAO,CAAC;YACjB,MAAM;QAEV,KAAK,KAAK,CAAC,QAAQ;YACf,MAAM,GAAG,MAAM,CAAC;YAChB,MAAM;KACb;IAED,KAAK,MAAM,EAAE,IAAI,GAAG,EAAE;QAClB,MAAM,EAAE,GAAG,QAAQ,CAAC,cAAc,CAAC,EAAE,CAAC,CAAC;QAEvC,IAAI,EAAE,IAAI,EAAE,CAAC,EAAE,KAAK,MAAM,EAAE;YACxB,EAAE,CAAC,KAAK,CAAC,OAAO,GAAG,MAAM,CAAC;SAC7B;KACJ;IAED,MAAM,EAAE,GAAG,QAAQ,CAAC,cAAc,CAAC,MAAM,CAAC,CAAC;IAE3C,IAAI,EAAE,EAAE;QACJ,EAAE,CAAC,KAAK,CAAC,OAAO,GAAG,SAAS,CAAC;KAChC;AACL,CAAC;AAED,gBAAgB,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC;AAEhC,MAAM,cAAc,GAAG,QAAQ,CAAC,cAAc,CAAC,gBAAgB,CAAsB,CAAC;AAEtF,cAAc,CAAC,OAAO,GAAG,GAAG,EAAE;IAC1B,OAAO,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC;AAC3B,CAAC,CAAC;AAEF,IAAI,CAAC,SAAS,CAAC,KAAK,EAAE,GAAU,EAAE,EAAE;IAChC,IAAI,GAAG,EAAE;QACL,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;QACnB,OAAO;KACV;IAED,MAAM,IAAI,CAAC,WAAW,CAAC,SAAS,EAAE,mBAAO,CAAC,wEAAqB,CAAC,CAAC,CAAC;IAElE,IAAI;QACA,MAAM,IAAI,CAAC,OAAO,CAAC,QAAQ,CAAC,OAAO,EAAE,UAAU,CAAC,CAAC;KACpD;IAAC,OAAO,GAAG,EAAE;QACV,OAAO,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;KACtB;IAED,OAAO,CAAC,GAAG,CAAC,IAAI,CAAC,CAAC;IAClB,gBAAgB,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;AACnC,CAAC,CAAC,CAAC;;;;;;;;;;;;ACpEH;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,EAAE;AACF;AACA;AACA;;;AAGA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;;AAGA;;AAEA;;AAEA;AACA;AACA;;;AAGA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;ACtGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,uCAAuC,SAAS;AAChD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA;;AAEA;AACA,E;;;;;;;;;;;ACzHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACtBA,mBAAmB,mBAAO,CAAC,oDAAW;AACtC,WAAW,mBAAO,CAAC,wDAAa;;AAEhC;;;AAGA;AACA;;;AAGA;AACA,SAAS;AACT;;;AAGA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,EAAE;AACF;AACA;AACA;;;AAGA;AACA;AACA;AACA,CAAC;;;AAGD;AACA;AACA;AACA,CAAC;;;;;;;;;;;;;ACxDD,WAAW,mBAAO,CAAC,0DAAY;;AAE/B;;;;;;;;;;;;ACFA;AACA,mBAAmB,mBAAO,CAAC,qEAAgB;;AAE3C;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;AAGA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA,gBAAgB,0BAA0B;AAC1C;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,qBAAqB,qBAAqB;AAC1C;;;AAGA;AACA,gBAAgB,0BAA0B;AAC1C;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA,iBAAiB,sBAAsB;AACvC;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI;AACJ;AACA;AACA,KAAK;AACL;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;;;AAGA;;;AAGA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,aAAa,SAAS;AACtB;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA,yCAAyC,SAAS;AAClD;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAI;AACJ;AACA;AACA;;;AAGA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;;AAGA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,YAAY,mBAAmB;AAC/B,YAAY,QAAQ;AACpB,cAAc,gBAAgB;AAC9B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,iBAAiB;AACnC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,YAAY,OAAO;AACnB;;AAEA;AACA,kCAAkC;;AAElC,iBAAiB,iBAAiB;AAClC;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,GAAG;AACH;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;AC5lBA,mBAAmB,mBAAO,CAAC,oDAAW;AACtC,eAAe,mBAAO,CAAC,6DAAU;;;AAGjC;AACA;AACA;;AAEA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;;AAEA,gBAAgB,kBAAkB;AAClC;AACA;AACA;;;AAGA;AACA,gBAAgB,mBAAmB;AACnC;;AAEA;AACA,kCAAkC;AAClC;AACA;AACA;;;;;;;;;;;;ACtEA,mBAAmB,mBAAO,CAAC,0DAAc;AACzC,eAAe,mBAAO,CAAC,0EAAsB;;;AAG7C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,gBAAgB,WAAW;AAC3B;;AAEA;;AAEA;AACA;;AAEA;AACA;;;AAGA;;AAEA;AACA;;AAEA;AACA;AACA,EAAE;AACF;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,gCAAgC;AAChC,MAAM;AACN;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;AClUA,mBAAmB,mBAAO,CAAC,oDAAW;AACtC,eAAe,mBAAO,CAAC,6DAAU;AACjC,mBAAmB,mBAAO,CAAC,sEAAgB;AAC3C,oBAAoB,mBAAO,CAAC,8EAAiB;AAC7C,gBAAgB,mBAAO,CAAC,gEAAa;AACrC,kBAAkB,mBAAO,CAAC,oEAAe;;;AAGzC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAW;AACX,GAAG;AACH,WAAW;AACX,GAAG;AACH,EAAE;AACF;;AAEA;AACA;AACA;AACA,GAAG;AACH,EAAE;AACF;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;AACA;;AAEA;;AAEA,wBAAwB;AACxB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA,0DAA0D;;AAE1D;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH,EAAE;AACF;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA,iBAAiB,iBAAiB;AAClC;;AAEA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA,wDAAwD;AACxD,4BAA4B;;AAE5B,gBAAgB,mBAAmB;AACnC;AACA;;AAEA,gBAAgB;AAChB;AACA,mBAAmB;AACnB,8GAA8G;AAC9G,eAAe,gBAAgB;AAC/B,kFAAkF;AAClF,6EAA6E;AAC7E,4BAA4B;AAC5B,gBAAgB;AAChB,cAAc;;AAEd;;AAEA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,iBAAiB,qBAAqB;AACtC;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,gBAAgB,yBAAyB;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;ACtWA,gBAAgB,mBAAO,CAAC,8EAAiB;;;AAGzC;AACA,qBAAqB;AACrB;AACA;AACA;;AAEA;AACA;;AAEA;;;AAGA;AACA;AACA,WAAW,OAAO;AAClB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,gBAAgB,mBAAmB;AACnC;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA,WAAW,OAAO;AAClB,YAAY,QAAQ;AACpB;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,EAAE;;AAEF;AACA;AACA;;AAEA,gBAAgB,uBAAuB;AACvC;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;ACpMA,kBAAkB,mBAAO,CAAC,qEAAgB;AAC1C,mBAAmB,mBAAO,CAAC,oDAAW;AACtC,eAAe,mBAAO,CAAC,6DAAU;;;AAGjC;AACA;;AAEA;;AAEA;AACA;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA;AACA;;;AAGA;AACA;AACA;;AAEA,uBAAuB,+BAA+B;AACtD,GAAG;AACH;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,IAAI;AACJ,GAAG;AACH;;AAEA;AACA;;;AAGA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAE;AACF;AACA;AACA;AACA;;;;;;;;;;;;ACtJA;AACA,cAAc,mBAAO,CAAC,oEAAQ;AAC9B,eAAe,mBAAO,CAAC,oEAAQ;AAC/B,YAAY,mBAAO,CAAC,gEAAM;AAC1B;;;AAGA;;;AAGA;AACA;AACA;AACA,WAAW,OAAO;AAClB,aAAa,OAAO;AACpB;;AAEA;AACA;;AAEA,gBAAgB,mBAAmB;AACnC;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;;;;;;;ACrCA,mBAAmB,mBAAO,CAAC,oDAAW;AACtC,eAAe,mBAAO,CAAC,6DAAU;;;AAGjC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,uDAAuD;AACvD;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA,GAAG;AACH;;;AAGA;AACA;AACA;;;AAGA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAI;AACJ;AACA;AACA;;AAEA,kBAAkB,uBAAuB;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,wBAAwB,oCAAoC;;AAE5D;AACA,IAAI;AACJ;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;;;;AC9JA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA,iBAAiB,SAAS;AAC1B;AACA;AACA,EAAE;AACF;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAE;AACF;AACA;;AAEA;AACA;;AAEA","file":"game.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./front/main.ts\");\n","import * as mage from 'mage-sdk-js';\r\n\r\nmage.setEndpoint('http://localhost:8080');\r\n\r\nenum State {\r\n    Loading,\r\n    Loaded,\r\n    LoggedIn,\r\n}\r\n\r\n// This is really dumb but dead simple for this little exercise\r\nfunction adjustVisibility(state: State) {\r\n    const all = ['loading', 'login', 'game'];\r\n    let toShow: string = '';\r\n\r\n    switch (state) {\r\n        case State.Loading:\r\n            toShow = 'loading';\r\n            break;\r\n\r\n        case State.Loaded:\r\n            toShow = 'login';\r\n            break;\r\n\r\n        case State.LoggedIn:\r\n            toShow = 'game';\r\n            break;\r\n    }\r\n\r\n    for (const id of all) {\r\n        const el = document.getElementById(id);\r\n\r\n        if (el && el.id !== toShow) {\r\n            el.style.display = 'none';\r\n        }\r\n    }\r\n\r\n    const el = document.getElementById(toShow);\r\n\r\n    if (el) {\r\n        el.style.display = 'inherit';\r\n    }\r\n}\r\n\r\nadjustVisibility(State.Loading);\r\n\r\nconst registerButton = document.getElementById('registerButton') as HTMLButtonElement;\r\n\r\nregisterButton.onclick = () => {\r\n    console.log('clicked');\r\n};\r\n\r\nmage.configure(async (err: Error) => {\r\n    if (err) {\r\n        console.error(err);\r\n        return;\r\n    }\r\n\r\n    await mage.setupModule('session', require('mage-sdk-js.session'));\r\n\r\n    try {\r\n        await mage.players.register('test2', 'testpass');\r\n    } catch (err) {\r\n        console.error(err);\r\n    }\r\n\r\n    console.log(mage);\r\n    adjustVisibility(State.Loaded);\r\n});\r\n","// State carries the time and bump state at a particular precision (factor)\n\nfunction State(factor) {\n\tthis.factor = factor || 1;\n\tthis.bump = 0;\n\tthis.time = null;\n}\n\n\nState.prototype.setTime = function (ts) {\n\tvar collides = false;\n\n\tif (this.time) {\n\t\t// apply the factor and compare the timestamps for collisions\n\n\t\tcollides = Math.floor(ts * this.factor) === Math.floor(this.time * this.factor);\n\t}\n\n\tthis.time = ts;\n\n\tif (collides) {\n\t\tthis.bump += 1;\n\t} else {\n\t\tthis.bump = 1;\n\t}\n};\n\n\n// The Puncher class exposes the punch method and carries multiple precision states\n\nfunction Puncher(defaults) {\n\tthis.defaults = defaults;\n\n\tthis.states = {\n\t\tsec: new State(0.001),\n\t\tmsec: new State()\n\t};\n}\n\n\nPuncher.prototype.punch = function (options) {\n\tif (options) {\n\t\tif (this.defaults) {\n\t\t\tfor (var key in this.defaults) {\n\t\t\t\tif (this.defaults.hasOwnProperty(key) && !options.hasOwnProperty(key)) {\n\t\t\t\t\toptions[key] = this.defaults[key];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t} else {\n\t\toptions = this.defaults || {};\n\t}\n\n\t// pick a state based on our precision\n\n\tvar state = options.msec ? this.states.msec : this.states.sec;\n\n\t// assign the current time to the state\n\n\tvar now = options.now || new Date();\n\tvar ts = now.getTime();\n\n\tstate.setTime(ts);\n\n\t// generate an output string\n\n\tvar out = ts;\n\n\tif (options.epoch instanceof Date) {\n\t\tout -= options.epoch.getTime();\n\t}\n\n\tif (!options.msec) {\n\t\tout = Math.floor(out / 1000);\n\t}\n\n\tif (typeof options.base === 'number') {\n\t\tout = out.toString(options.base);\n\t}\n\n\tout += '-' + state.bump;\n\n\treturn out;\n};\n\n\n// Expose the default punch method\n\nvar defaultPuncher = new Puncher();\n\nexports.punch = function (options) {\n\treturn defaultPuncher.punch(options);\n};\n\n\n// A factory for new cache punchers\n\nexports.create = function (defaults) {\n\tvar puncher = new Puncher(defaults);\n\n\treturn function (options) {\n\t\treturn puncher.punch(options);\n\t};\n};\n\n","\nvar EventEmitter = function () {\n\tthis.eventHandlers = {};\n};\nEventEmitter.EventEmitter = EventEmitter;\nmodule.exports = EventEmitter;\n\nEventEmitter.listenerCount = function (emitter, evt) {\n\tvar eventHandlers = emitter.eventHandlers[evt];\n\treturn eventHandlers ? eventHandlers.length : 0;\n};\n\nEventEmitter.prototype.on = function (evt, fn) {\n\tif (typeof fn !== 'function') {\n\t\tconsole.warn('Tried to register non-function', fn, 'as event handler for event:', evt);\n\t\treturn this;\n\t}\n\n\tthis.emit('newListener', evt, fn);\n\n\tvar allHandlers = this.eventHandlers;\n\tvar evtHandlers = allHandlers[evt];\n\tif (evtHandlers === undefined) {\n\t\t// first event handler for this event type\n\t\tallHandlers[evt] = [fn];\n\t\treturn this;\n\t}\n\n\tevtHandlers.push(fn);\n\treturn this;\n};\n\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\nEventEmitter.prototype.once = function (evt, fn) {\n\tif (!fn.once) {\n\t\tfn.once = 1;\n\t} else {\n\t\tfn.once += 1;\n\t}\n\n\treturn this.on(evt, fn);\n};\n\nEventEmitter.prototype.setMaxListeners = function () {\n\tconsole.warn('Method setMaxListeners not supported, there is no limit to the number of listeners');\n};\n\nEventEmitter.prototype.removeListener = function (evt, handler) {\n\t// like node.js, we only remove a single listener at a time, even if it occurs multiple times\n\n\tvar handlers = this.eventHandlers[evt];\n\tif (handlers !== undefined) {\n\t\tvar index = handlers.indexOf(handler);\n\t\tif (index !== -1) {\n\t\t\thandlers.splice(index, 1);\n\t\t\tthis.emit('removeListener', evt, handler);\n\t\t\tif (handlers.length === 0) {\n\t\t\t\tdelete this.eventHandlers[evt];\n\t\t\t}\n\t\t}\n\t}\n\treturn this;\n};\n\nEventEmitter.prototype.removeAllListeners = function (evt) {\n\tif (evt) {\n\t\tdelete this.eventHandlers[evt];\n\t} else {\n\t\tthis.eventHandlers = {};\n\t}\n\treturn this;\n};\n\nEventEmitter.prototype.hasListeners = function (evt) {\n\treturn (this.eventHandlers[evt] !== undefined);\n};\n\nEventEmitter.prototype.listeners = function (evt) {\n\tvar handlers = this.eventHandlers[evt];\n\tif (handlers !== undefined) {\n\t\treturn handlers.slice();\n\t}\n\n\treturn [];\n};\n\nvar slice = Array.prototype.slice;\nEventEmitter.prototype.emit = function (evt) {\n\n\tvar handlers = this.eventHandlers[evt];\n\tif (handlers === undefined) {\n\t\treturn false;\n\t}\n\n\t// copy handlers into a new array, so that handler removal doesn't affect array length\n\thandlers = handlers.slice();\n\n\tvar hadListener = false;\n\tvar args = slice.call(arguments, 1);\n\tfor (var i = 0, len = handlers.length; i < len; i++) {\n\t\tvar handler = handlers[i];\n\t\tif (handler === undefined) {\n\t\t\tcontinue;\n\t\t}\n\n\t\thandler.apply(this, args);\n\t\thadListener = true;\n\n\t\tif (handler.once) {\n\t\t\tif (handler.once > 1) {\n\t\t\t\thandler.once--;\n\t\t\t} else {\n\t\t\t\tdelete handler.once;\n\t\t\t}\n\n\t\t\tthis.removeListener(evt, handler);\n\t\t}\n\t}\n\n\treturn hadListener;\n};","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n","var EventEmitter = require('events.js');\nvar mage = require('mage-sdk-js');\n\nexports = module.exports = new EventEmitter();\n\n\nvar sessionKey;\nvar actorId;\n\n\nfunction commandHook() {\n\treturn { key: sessionKey };\n}\n\n\n// Some day, we'll need to deprecate actorId from this module.\n// It's the login system that needs to provide an actor ID, not the session system\n\nexports.getActorId = function () {\n\treturn actorId;\n};\n\nexports.setActorId = function (id) {\n\tactorId = id;\n};\n\n\nexports.getKey = function () {\n\treturn sessionKey;\n};\n\nexports.setKey = function (key) {\n\tif (key === sessionKey) {\n\t\t// no change\n\t\treturn;\n\t}\n\n\tsessionKey = key;\n\n\tif (key) {\n\t\tmage.commandCenter.registerCommandHook('mage.session', commandHook);\n\t} else {\n\t\tmage.commandCenter.unregisterCommandHook('mage.session');\n\t}\n};\n\n\nmage.eventManager.on('session.set', function (path, info) {\n\texports.setActorId(info.actorId);\n\texports.setKey(info.key);\n});\n\n\nmage.eventManager.on('session.unset', function () {\n\texports.setActorId(null);\n\texports.setKey(null);\n});\n\n","var Mage = require('./lib/Mage');\n\nmodule.exports = new Mage();\n","function CommandCenter(eventManager) {\n\tvar HttpRequest = require('../HttpRequest');\n\n\tthis.transports = {\n\t\thttp: HttpRequest\n\t};\n\n\tthis.cmdHooks = [];\n\n\tthis.queryId = 0;\n\tthis.commandSystemStarted = false;\n\tthis.cmdMode = 'free';\n\tthis.simulatedTransportError = null;\n\tthis.simulatedCommandError = null;\n\n\tthis.eventManager = eventManager;\n}\n\nmodule.exports = CommandCenter;\n\n\n// transport\n\nCommandCenter.prototype.createTransport = function (type, options) {\n\t// check transport availability\n\n\tvar Transport = this.transports[type];\n\tif (!Transport) {\n\t\tthrow new Error('No transport type \"' + type + '\" found.');\n\t}\n\n\treturn new Transport({\n\t\tnoCache: true,\n\t\twithCredentials: options && options.cors && options.cors.credentials ? true : false\n\t});\n};\n\n// command center\n\nCommandCenter.prototype.setCmdMode = function (mode) {\n\tif (mode !== 'free' && mode !== 'blocking') {\n\t\tthrow new Error('Unrecognized command mode \"' + mode + '\", use \"free\" or \"blocking\".');\n\t}\n\n\tthis.cmdMode = mode;\n};\n\n\nCommandCenter.prototype.registerCommandHook = function (name, fn) {\n\t// replace the old command hook if there is one\n\n\tfor (var i = 0; i < this.cmdHooks.length; i += 1) {\n\t\tvar cmdHook = this.cmdHooks[i];\n\n\t\tif (cmdHook.name === name) {\n\t\t\tcmdHook.fn = fn;\n\t\t\treturn;\n\t\t}\n\t}\n\n\t// else append to the end\n\n\tthis.cmdHooks.push({ name: name, fn: fn });\n};\n\n\nCommandCenter.prototype.unregisterCommandHook = function (name) {\n\tfor (var i = 0; i < this.cmdHooks.length; i += 1) {\n\t\tvar cmdHook = this.cmdHooks[i];\n\n\t\tif (cmdHook.name === name) {\n\t\t\tthis.cmdHooks.splice(i, 1);\n\t\t\treturn;\n\t\t}\n\t}\n};\n\n\nCommandCenter.prototype.sendCommand = function () {\n\tconsole.warn('CommandCenter#sendCommand: command system not yet set up.');\n};\n\n\nCommandCenter.prototype.resend = function () {\n\tconsole.warn('CommandCenter#resend: command system not yet set up.');\n};\n\n\nCommandCenter.prototype.discard = function () {\n\tconsole.warn('CommandCenter#discard: command system not yet set up.');\n};\n\n\nCommandCenter.prototype.queue = function () {\n\tconsole.warn('CommandCenter#queue: command system not yet set up.');\n};\n\n\nCommandCenter.prototype.piggyback = function () {\n\tconsole.warn('CommandCenter#piggyback: command system not yet set up.');\n};\n\n\nCommandCenter.prototype.simulateTransportError = function (type) {\n\tthis.simulatedTransportError = type;\n};\n\nCommandCenter.prototype.simulateCommandError = function (cmdName, error) {\n\tthis.simulatedCommandError = {\n\t\tcmdName: cmdName,\n\t\terror: error\n\t};\n};\n\nCommandCenter.prototype.setupCommandSystem = function (config) {\n\tif (this.commandSystemStarted) {\n\t\treturn;\n\t}\n\n\tvar hr = this.createTransport('http', config.httpOptions);\n\n\tvar that = this;\n\n\t// if this timer is active, we're about to send batches.current (which may still grow).\n\tvar timer = null;\n\n\t// if \"streaming\" is true, we will send batches.current the moment the running request returns.\n\tvar streaming = false;\n\n\t// placeholder for unlock function, to avoid circular refs and upset jslint\n\tvar unlock;\n\n\tvar batches = {\n\t\tcurrent: [],  // the commands we're building that will be sent _very_ soon\n\t\tsending: []   // the commands that are currently being sent\n\t};\n\n\t// \"queueing\" is true when user commands are to be stored in the current batch, and should be\n\t// sent off asap (through commandCenter.queue method)\n\tvar queueing = false;\n\n\t// \"piggybacking\" is true when user commands are to be stored in the current batch (through\n\t// commandCenter.piggyback method)\n\tvar piggybacking = false;\n\n\t// \"locked\" is true for as long as a queryId has not been successfully completed.\n\tvar locked = false;\n\n\n\tfunction onCommandResponse(transportError, responses) {\n\t\t// this is the response to the request that is now in the batches.sending array\n\t\t// [\n\t\t//   [sysError] or:\n\t\t//   [null, userError] or:\n\t\t//   [null, null, response obj, events array] // where events may be left out\n\t\t// ]\n\n\t\tif (that.simulatedTransportError) {\n\t\t\ttransportError = that.simulatedTransportError;\n\t\t\tthat.simulatedTransportError = null;\n\t\t}\n\n\t\tif (transportError) {\n\t\t\t// \"network\": network failure (offline or timeout), retry is the only correct option\n\t\t\t// \"busy\": usually treat quietly\n\n\t\t\treturn that.eventManager.emitEvent('io.error.' + transportError, {\n\t\t\t\treason: transportError,\n\t\t\t\tinfo: responses\n\t\t\t});\n\t\t}\n\n\t\t// unlock the command system for the next user command(s)\n\n\t\tvar batch = batches.sending;\n\n\t\tunlock();\n\n\t\t// from here on, handle all responses and drop the queue that we just received answers to\n\n\t\tthat.eventManager.emitEvent('io.response');\n\n\t\t// handle the command responses\n\n\t\tfor (var i = 0; i < responses.length; i += 1) {\n\t\t\tvar response = responses[i];\n\t\t\tvar cmd = batch[i];\n\n\t\t\tif (!cmd) {\n\t\t\t\tconsole.warn('No command found for response', response);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tvar errorCode = response[0];\n\t\t\tvar cmdResponse = response[1];\n\t\t\tvar events = response[2];\n\n\t\t\tif (that.simulatedCommandError && that.simulatedCommandError.cmdName === cmd.name) {\n\t\t\t\terrorCode = that.simulatedCommandError.error;\n\t\t\t\tcmdResponse = null;\n\t\t\t\tevents = null;\n\t\t\t\tthat.simulatedCommandError = null;\n\t\t\t}\n\n\t\t\tif (events) {\n\t\t\t\tthat.eventManager.emitEvents(events);\n\t\t\t}\n\n\t\t\t/*\n\t\t\tcmd = {\n\t\t\t  name: cmdName,\n\t\t\t  params: params,\n\t\t\t  files: files,\n\t\t\t  cb: cb,\n\t\t\t  responsePromise: responsePromise\n\t\t\t};\n\t\t\t*/\n\n\t\t\tif (!errorCode) {\n\t\t\t\tthat.eventManager.emit('io.' + cmd.name, cmdResponse, cmd.params);\n\t\t\t}\n\n\t\t\tif (cmd.cb) {\n\t\t\t\tif (errorCode) {\n\t\t\t\t\tcmd.cb(errorCode);\n\t\t\t\t} else {\n\t\t\t\t\tcmd.cb(null, cmdResponse);\n\t\t\t\t}\n\t\t\t} else if (cmd.responsePromise) {\n\t\t\t\tif (errorCode) {\n\t\t\t\t\tcmd.responsePromise.reject(errorCode);\n\t\t\t\t} else {\n\t\t\t\t\tcmd.responsePromise.resolve(cmdResponse);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthrow new Error('Cannot send command response: no callback or promise found');\n\t\t\t}\n\t\t}\n\t}\n\n\n\tvar nextFileId = 0;\n\n\n\tfunction sendBatch(batch) {\n\t\t// no need to check for locked here, since that is taken care of by the caller of sendBatch\n\n\t\tlocked = true;\n\t\ttimer = null;\n\n\t\tnextFileId = 0;\n\n\t\tvar i, len;\n\n\t\t// prepare data extraction\n\n\t\tlen = batch.length;\n\n\t\tvar cmdNames = new Array(len);\n\t\tvar cmdParams = new Array(len);\n\t\tvar hasCallbacks = false;\n\t\tvar header = [], data, files;\n\n\t\tfor (i = 0; i < len; i += 1) {\n\t\t\tvar cmd = batch[i];\n\n\t\t\tcmdNames[i] = cmd.name;\n\t\t\tcmdParams[i] = cmd.params;\n\n\t\t\tif (cmd.files) {\n\t\t\t\tif (!files) {\n\t\t\t\t\tfiles = {};\n\t\t\t\t}\n\n\t\t\t\tfor (var fileId in cmd.files) {\n\t\t\t\t\tif (cmd.files.hasOwnProperty(fileId)) {\n\t\t\t\t\t\tfiles[fileId] = cmd.files[fileId];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (cmd.cb) {\n\t\t\t\thasCallbacks = true;\n\t\t\t}\n\t\t}\n\n\t\tdata = cmdParams.join('\\n');\n\n\t\t// execute all hooks\n\n\t\tfor (i = 0, len = that.cmdHooks.length; i < len; i += 1) {\n\t\t\tvar hook = that.cmdHooks[i];\n\n\t\t\tvar hookOutput = hook.fn(data);\n\t\t\tif (hookOutput) {\n\t\t\t\thookOutput.name = hook.name;\n\n\t\t\t\theader.push(hookOutput);\n\t\t\t}\n\t\t}\n\n\t\t// emit io.send event with all command names as the argument\n\n\t\tthat.eventManager.emitEvent('io.send', cmdNames);\n\n\t\t// create a request\n\n\t\tvar url = encodeURI(config.url + '/' + cmdNames.join(','));\n\t\tvar urlParams = {};\n\n\t\tif (hasCallbacks) {\n\t\t\turlParams.queryId = that.queryId;\n\t\t}\n\n\t\t// prepend the header before the cmd parameter data\n\n\t\tdata = JSON.stringify(header) + '\\n' + data;\n\n\t\t// send request to server\n\n\t\tif (files) {\n\t\t\tvar FormData = window.FormData;\n\n\t\t\tif (FormData) {\n\t\t\t\tvar form = new FormData();\n\t\t\t\tform.append('cmddata', data);\n\n\t\t\t\tfor (var name in files) {\n\t\t\t\t\tif (files.hasOwnProperty(name)) {\n\t\t\t\t\t\tform.append(name, files[name]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tdata = form;\n\t\t\t} else {\n\t\t\t\tconsole.warn('window.FormData class not available, old browser?');\n\t\t\t}\n\t\t}\n\n\n\t\thr.send('POST', url, urlParams, data, null, onCommandResponse);\n\t}\n\n\n\tfunction sendCurrentBatch() {\n\t\tbatches.sending = batches.current;\n\t\tbatches.current = [];\n\n\t\t// set streaming to false, a next user command can turn it on again\n\n\t\tstreaming = false;\n\n\t\tsendBatch(batches.sending);\n\t}\n\n\n\tfunction scheduleCurrentBatch() {\n\t\t// - Set streaming to true, so nothing can pause us\n\t\t// - If no timer has been set yet, create a query ID, start a timer and prepare to\n\t\t//   send a new batch.\n\n\t\tstreaming = true;\n\n\t\tif (locked) {\n\t\t\t// if the current stream is locked, the unlocking will trigger this function to be\n\t\t\t// called again.\n\t\t\treturn;\n\t\t}\n\n\t\tif (timer === null) {\n\t\t\tthat.queryId += 1;\n\t\t\ttimer = window.setTimeout(sendCurrentBatch, 0);\n\n\t\t\tthat.eventManager.emitEvent('io.queued', that.queryId);\n\t\t}\n\t}\n\n\n\tfunction resendBatch() {\n\t\tsendBatch(batches.sending);\n\t}\n\n\n\tunlock = function () {\n\t\t// discard the last sent batch\n\n\t\tbatches.sending = [];\n\n\t\tlocked = false;\n\n\t\t// if there is a batch ready to be sent again, trigger the send\n\n\t\tif (batches.current.length > 0 && streaming) {\n\t\t\tscheduleCurrentBatch();\n\t\t}\n\t};\n\n\n\t// file upload helpers\n\n\tvar uploads;\n\n\tfunction Upload(file) {\n\t\tthis.file = file;\n\t}\n\n\tUpload.prototype.toJSON = function () {\n\t\t// returns the ID of the file\n\n\t\tvar id = '__file' + nextFileId;\n\n\t\tnextFileId += 1;\n\n\t\tif (!uploads) {\n\t\t\tuploads = {};\n\t\t}\n\n\t\tuploads[id] = this.file;\n\n\t\treturn id;\n\t};\n\n\n\tvar Blob = window.Blob;\n\tvar File = window.File;\n\tvar FileList = window.FileList;\n\n\n\t/**\n\t * Use this method to transform a File, Blob or FileList object to an object type that commandCenter\n\t * can upload. The result of this function may safely be put in of any parameter of a user\n\t * command call.\n\t *\n\t * @param {File|Blob|FileList} file\n\t * @param {boolean} silent          Set to true to suppress errors when the type doesn't match\n\t * @returns {Upload|Upload[]}       An Upload instance, or an array of Upload instances\n\t */\n\n\tthis.transformUpload = function (file, silent) {\n\t\tif (file instanceof Blob || file instanceof File) {\n\t\t\treturn new Upload(file);\n\t\t}\n\n\t\tif (file instanceof FileList) {\n\t\t\tvar list = [];\n\n\t\t\tfor (var i = 0; i < file.length; i += 1) {\n\t\t\t\tlist.push(new Upload(file[i]));\n\t\t\t}\n\n\t\t\treturn list;\n\t\t}\n\n\t\tif (!silent) {\n\t\t\tthrow new TypeError('Given argument is not a Blob, File or FileList');\n\t\t}\n\t};\n\n\n\t/**\n\t * This will deep-inspect any given object and transform File, Blob or FileList objects using\n\t * the transformUpload method.\n\t *\n\t * @param {Object} obj\n\t */\n\n\tthis.transformEmbeddedUploads = function (obj) {\n\t\tvar keys = Object.keys(obj || {});\n\n\t\tfor (var i = 0; i < keys.length; i += 1) {\n\t\t\tvar value = obj[keys[i]];\n\n\t\t\tif (value && typeof value === 'object') {\n\t\t\t\tvar upload = this.transformUpload(value, true);\n\n\t\t\t\tif (upload) {\n\t\t\t\t\tobj[keys[i]] = upload;\n\t\t\t\t} else {\n\t\t\t\t\tthis.transformEmbeddedUploads(obj[keys[i]]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\n\tthis.sendCommand = function (cmdName, params, cb) {\n\t\tif (typeof cmdName !== 'string') {\n\t\t\tthrow new TypeError('Command name is not a string: ' + cmdName);\n\t\t}\n\n\t\tif (params && typeof params !== 'object') {\n\t\t\tthrow new TypeError('Command params is not an object: ' + params);\n\t\t}\n\n\t\tif (cb && typeof cb !== 'function') {\n\t\t\tthrow new TypeError('Command callback is not a function: ' + cb);\n\t\t}\n\n\t\t// cmdName is dot notation \"moduleName.commandName\"\n\n\t\t// Serialize the params instantly, so that they may be altered right after this call without\n\t\t// affecting command execution. The uploads list should be reset before, and after\n\t\t// stringification.\n\n\t\tuploads = null;\n\n\t\tparams = JSON.stringify(params);\n\n\t\t// If not callback-based, setup promise\n\t\tvar responsePromise = {};\n\t\tvar promise = null;\n\t\tif (!cb) {\n\t\t\tpromise = new Promise(function (resolve, reject) {\n\t\t\t\tresponsePromise.resolve = resolve;\n\t\t\t\tresponsePromise.reject = reject;\n\t\t\t});\n\t\t}\n\n\t\t// create the command object\n\n\t\tvar cmd = {\n\t\t\tname: cmdName,\n\t\t\tparams: params,\n\t\t\tfiles: uploads,\n\t\t\tcb: cb,\n\t\t\tresponsePromise: responsePromise\n\t\t};\n\n\t\tuploads = null;\n\n\n\t\tif (piggybacking) {\n\t\t\t// Add the command to the current queue, but don't start sending anything just yet.\n\t\t\t// The next batch that gets scheduled will take these along.\n\n\t\t\tbatches.current.push(cmd);\n\t\t} else if (locked) {\n\t\t\t// We're currently sending, but if the next batch is accessible, we can add the command\n\t\t\t// to it. That way it will be sent when the open request returns.\n\n\t\t\tif (queueing || that.cmdMode === 'free') {\n\t\t\t\t// add to current batch and make sure it will be sent off\n\n\t\t\t\tbatches.current.push(cmd);\n\n\t\t\t\tscheduleCurrentBatch();\n\t\t\t} else {\n\t\t\t\tconsole.warn('Could not execute user command: busy.', cmd);\n\n\t\t\t\tthat.eventManager.emitEvent('io.error.busy', {\n\t\t\t\t\treason: 'busy',\n\t\t\t\t\tcommand: cmd,\n\t\t\t\t\tblockedBy: batches.sending\n\t\t\t\t});\n\t\t\t}\n\t\t} else {\n\t\t\t// The command can be executed right now, so add to the current batch and make sure it\n\t\t\t// will be sent off\n\n\t\t\tbatches.current.push(cmd);\n\n\t\t\tscheduleCurrentBatch();\n\t\t}\n\n\t\treturn promise;\n\t};\n\n\n\t// the discard function can be called if after a transport error, when do not want to retry\n\t// it will unlock the command center for the next user command\n\n\tthis.discard = function () {\n\t\tunlock();\n\t\tthat.eventManager.emitEvent('io.discarded');\n\t};\n\n\n\tthis.resend = function () {\n\t\tif (!batches.sending.length) {\n\t\t\tconsole.warn('No commands to retry. Discarding instead.');\n\t\t\tthat.discard();\n\t\t\treturn;\n\t\t}\n\n\t\tthat.eventManager.emitEvent('io.resend');\n\n\t\tresendBatch();\n\t};\n\n\n\tthis.queue = function (fn) {\n\t\tqueueing = true;\n\t\tfn();\n\t\tqueueing = false;\n\t};\n\n\n\tthis.piggyback = function (fn) {\n\t\tpiggybacking = true;\n\t\tfn();\n\t\tpiggybacking = false;\n\t};\n\n\tthis.commandSystemStarted = true;\n};\n","var EventEmitter = require('events.js');\nvar inherits = require('inherits');\n\n\nfunction EventManager() {\n\tEventEmitter.call(this);\n}\n\ninherits(EventManager, EventEmitter);\n\nmodule.exports = EventManager;\n\n\nfunction parsePath(path) {\n\tif (typeof path === 'string') {\n\t\tif (path.length === 0) {\n\t\t\tthrow new Error('An empty path is not a valid event path');\n\t\t}\n\n\t\treturn path.split('.');\n\t}\n\n\tif (Array.isArray(path)) {\n\t\tif (path.length === 0) {\n\t\t\tthrow new Error('An empty path is not a valid event path');\n\t\t}\n\n\t\t// make a copy, because we'll be mutating it\n\t\treturn path.slice();\n\t}\n\n\tthrow new TypeError('An event path must be a non-empty array or a string');\n}\n\n\nfunction createPathFamily(path) {\n\t// longest paths first\n\n\tvar family = [];\n\n\tpath = parsePath(path);\n\n\twhile (path.length > 0) {\n\t\tfamily.push(path.join('.'));\n\t\tpath.pop();\n\t}\n\n\treturn family;\n}\n\n\nEventManager.prototype.emitEvent = function (fullPath, params) {\n\t// accepts only a single params object (which may be of any type)\n\n\tvar paths = createPathFamily(fullPath);\n\n\tfor (var i = 0; i < paths.length; i += 1) {\n\t\tthis.emit(paths[i], fullPath, params);\n\t}\n};\n\n\nEventManager.prototype.emitEvents = function (events) {\n\tfor (var i = 0; i < events.length; i += 1) {\n\t\tvar evt = events[i];\n\n\t\tif (evt) {\n\t\t\tthis.emitEvent(evt[0], evt[1]); // magic array positions: path, params\n\t\t}\n\t}\n};\n","var cachepuncher = require('cachepuncher');\nvar deepCopy = require('wizcorp-deep-copy.js');\n\n\nfunction addParamsToUrl(url, params) {\n\tif (!params) {\n\t\treturn url;\n\t}\n\n\tvar keys = Object.keys(params);\n\tvar count = keys.length;\n\n\tif (count === 0) {\n\t\treturn url;\n\t}\n\n\tvar splitter = url.indexOf('?') === -1 ? '?' : '&';\n\n\tfor (var i = 0; i < count; i += 1) {\n\t\tvar key = keys[i];\n\n\t\turl += splitter + encodeURIComponent(key) + '=' + encodeURIComponent(params[key]);\n\n\t\tsplitter = '&';\n\t}\n\n\treturn url;\n}\n\n\n// safe XHR data extractors (will not throw)\n\nfunction getStatusCode(xhr) {\n\tvar status;\n\n\ttry {\n\t\tstatus = xhr.status;\n\t} catch (error) {\n\t\treturn 0;\n\t}\n\n\t// IE CORS compatibility\n\n\tif (typeof status !== 'number') {\n\t\tstatus = 200;\n\t}\n\n\treturn status;\n}\n\n\nfunction getResponseText(xhr) {\n\tvar response;\n\n\ttry {\n\t\tresponse = xhr.responseText;\n\t} catch (error) {\n\t\t// do nothing, we'll return undefined\n\t}\n\n\treturn response;\n}\n\n\nfunction getContentType(xhr) {\n\tvar type;\n\n\ttry {\n\t\ttype = xhr.contentType;\n\t} catch (error) {\n\t\t// ignore, we'll try getResponseHeader\n\t}\n\n\tif (!type) {\n\t\ttry {\n\t\t\ttype = xhr.getResponseHeader('content-type');\n\t\t} catch (getError) {\n\t\t\t// ignore, we'll return undefined\n\t\t}\n\t}\n\n\treturn type;\n}\n\n\nfunction createCORSRequest() {\n\tvar xhr = new XMLHttpRequest();\n\tif ('withCredentials' in xhr) {\n\t\t// XHR for Chrome/Firefox/Opera/Safari.\n\t\treturn xhr;\n\t}\n\n\tif (window.XDomainRequest) {\n\t\t// XDomainRequest for IE.\n\t\treturn new window.XDomainRequest();\n\t}\n\n\treturn xhr;\n}\n\nfunction HttpRequest(options) {\n\toptions = options || {};\n\n\tvar xhr = createCORSRequest();\n\n\tvar callback;\n\tvar isSending = false;\n\tvar timer;\n\tvar FormData = window.FormData;\n\n\n\tthis.isBusy = function () {\n\t\treturn isSending;\n\t};\n\n\n\tthis.send = function (method, url, params, data, headers, cb) {\n\t\tif (typeof method !== 'string') {\n\t\t\tthrow new TypeError('method is not a string: ' + method);\n\t\t}\n\n\t\tif (typeof url !== 'string') {\n\t\t\tthrow new TypeError('url is not a string: ' + url);\n\t\t}\n\n\t\tif (params && typeof params !== 'object') {\n\t\t\tthrow new TypeError('params is not an object: ' + params);\n\t\t}\n\n\t\tif (headers && typeof headers !== 'object') {\n\t\t\tthrow new TypeError('headers is not an object: ' + headers);\n\t\t}\n\n\t\tif (isSending) {\n\t\t\tif (cb) {\n\t\t\t\tcb('busy');\n\t\t\t}\n\n\t\t\treturn false;\n\t\t}\n\n\t\tisSending = true;\n\t\tcallback = cb;\n\n\t\theaders = headers || {};\n\n\t\tvar m = url.match(/^[a-z]+:(\\/\\/)([^:]+:[^:]+)@/i);\n\t\tif (m) {\n\t\t\theaders.Authorization = 'Basic ' + window.btoa(m[2]);\n\t\t}\n\n\t\tif (params) {\n\t\t\tif (options.noCache) {\n\t\t\t\tparams = deepCopy(params);\n\t\t\t\tparams.rand = cachepuncher.punch();\n\t\t\t}\n\n\t\t\turl = addParamsToUrl(url, params);\n\t\t}\n\n\t\txhr.open(method, url, true);\n\n\t\tif (options.withCredentials) {\n\t\t\txhr.withCredentials = true;\n\t\t}\n\n\t\tif (data) {\n\t\t\tif (!FormData || !(data instanceof FormData)) {\n\t\t\t\tif (!headers.hasOwnProperty('content-type')) {\n\t\t\t\t\tvar contentType;\n\n\t\t\t\t\tif (typeof data === 'string') {\n\t\t\t\t\t\tcontentType = 'text/plain; charset=UTF-8';\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcontentType = 'application/json';\n\t\t\t\t\t\tdata = JSON.stringify(data);\n\t\t\t\t\t}\n\n\t\t\t\t\tif ('setRequestHeader' in xhr) {\n\t\t\t\t\t\txhr.setRequestHeader('content-type', contentType);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tdata = null;\n\t\t}\n\n\t\tif ('setRequestHeader' in xhr) {\n\t\t\tfor (var key in headers) {\n\t\t\t\tif (headers.hasOwnProperty(key)) {\n\t\t\t\t\txhr.setRequestHeader(key, headers[key]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tif (options.timeout) {\n\t\t\tif (options.timeout < 1000) {\n\t\t\t\tthrow new Error('Unreasonable timeout setting for HTTP request: ' + options.timeout + ' msec.');\n\t\t\t}\n\n\t\t\ttimer = setTimeout(function () {\n\t\t\t\tvar cb = callback;\n\t\t\t\tcallback = null;\n\n\t\t\t\tconsole.warn('HTTP request timed out, aborting');\n\n\t\t\t\txhr.abort();\n\n\t\t\t\t// in some browsers, oncomplete will now fire due to abort()\n\t\t\t\t// since callback is now null however, it will not do anything\n\n\t\t\t\tisSending = false;\n\n\t\t\t\tif (cb) {\n\t\t\t\t\tcb('network');\n\t\t\t\t}\n\t\t\t}, options.timeout);\n\t\t}\n\n\t\txhr.send(data);\n\n\t\treturn true;\n\t};\n\n\n\tthis.abort = function () {\n\t\t// abort does not call any callbacks\n\t\t// useful for long polling\n\n\t\tcallback = null;\n\t\tisSending = false;\n\n\t\ttry {\n\t\t\txhr.abort();\n\t\t} catch (abortError) {\n\t\t\t// ignore\n\t\t\tconsole.error(abortError);\n\t\t}\n\t};\n\n\n\tfunction oncomplete() {\n\t\t// possible error codes sent back to callback:\n\t\t// 'network': connection issue\n\t\t// 'maintenance': server is in maintenance\n\n\t\tisSending = false;\n\n\t\tif (!callback) {\n\t\t\treturn;\n\t\t}\n\n\t\tvar cb = callback;\n\t\tcallback = null;\n\n\t\t// the two variables we'll return in the callback, possibly returned as undefined\n\n\t\tvar error, response;\n\n\t\t// extract data from XHR\n\n\t\tvar code = getStatusCode(xhr);\n\t\tvar rawResponse = getResponseText(xhr);\n\t\tvar contentType = getContentType(xhr);\n\t\tvar codeCategory = (code / 100) >>> 0;\n\n\t\t// detect errors\n\n\t\tif (codeCategory !== 2) {\n\t\t\t// error situation\n\n\t\t\tif (code === 503) {\n\t\t\t\terror = 'maintenance';\n\t\t\t} else {\n\t\t\t\terror = 'network';\n\t\t\t}\n\n\t\t\tconsole.warn('HTTP response code:', code, 'set as error:', error);\n\t\t}\n\n\t\t// detect and parse response body\n\n\t\tif (rawResponse && contentType) {\n\t\t\tif (contentType.match(/^[a-z]+\\/json/)) {\n\t\t\t\ttry {\n\t\t\t\t\tresponse = JSON.parse(rawResponse);\n\t\t\t\t} catch (e) {\n\t\t\t\t\tconsole.warn('JSON parse error on HTTP response', e, rawResponse);\n\n\t\t\t\t\terror = error || 'server';\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tresponse = rawResponse;\n\t\t\t}\n\t\t}\n\n\t\tcb(error, response);\n\t}\n\n\tfunction onLoad() {\n\t\tif (timer) {\n\t\t\tclearTimeout(timer);\n\t\t\ttimer = null;\n\t\t}\n\n\t\tsetTimeout(function () {\n\t\t\toncomplete();\n\t\t}, 0);\n\t}\n\n\tif ('onload' in xhr) {\n\t\txhr.onload = onLoad;\n\t\txhr.onerror = onLoad;\n\t} else {\n\t\txhr.onreadystatechange = function () {\n\t\t\tif (xhr.readyState === 4) {\n\t\t\t\tonLoad();\n\t\t\t}\n\t\t};\n\t}\n}\n\nmodule.exports = HttpRequest;\n","var EventEmitter = require('events.js');\nvar inherits = require('inherits');\nvar EventManager = require('./EventManager');\nvar CommandCenter = require('./CommandCenter');\nvar MsgServer = require('./MsgServer');\nvar HttpRequest = require('./HttpRequest');\n\n\nfunction MageNotConfiguredError() {\n\treturn new Error('Please call mage.configure before calling any method');\n}\n\nfunction MageConfigureError(errMsg) {\n\terrMsg = errMsg || '';\n\treturn new Error(\n\t\t'Failed to configure MAGE: ' + errMsg + '\\n' +\n\t\t'Please ensure that:\\n' +\n\t\t'1. You have a MAGE server running at the configured enpoint\\n' +\n\t\t'2. You activated the config module on your MAGE server'\n\t);\n}\n\nfunction Mage() {\n\tEventEmitter.call(this);\n\n\tthis.eventManager = new EventManager();\n\tthis.msgServer = new MsgServer(this.eventManager);\n\tthis.commandCenter = new CommandCenter(this.eventManager);\n}\n\ninherits(Mage, EventEmitter);\n\nmodule.exports = Mage;\n\nMage.prototype.batchCommands = function (commands, cb) {\n\tif (cb && typeof cb !== 'function') {\n\t\tthrow new TypeError('mage.batchCommands callback is not a function: ' + cb);\n\t}\n\n\tvar batch = commands.map(function (command) {\n\t\treturn command.catch(function (err) {\n\t\t\treturn { data: null, error: err };\n\t\t}).then(function (res) {\n\t\t\treturn { data: res, error: null };\n\t\t});\n\t});\n\tvar promises = Promise.all(batch);\n\n\tif (cb) {\n\t\tpromises.then(function (res) {\n\t\t\tcb(null, res);\n\t\t});\n\t} else {\n\t\treturn promises;\n\t}\n};\n\n// call config.get usercommand to get client config and init mage SDK with it\n//\n// the usercommand is called manually because CommandCenter needs the config to setup\n\nMage.prototype.configure = function (cb) {\n\tif (!this.endpoint) {\n\t\tthrow new Error('Please call mage.setEndpoint before calling mage.configure');\n\t}\n\n\tvar that = this;\n\tvar hr = new HttpRequest({\n\t\tnoCache: true,\n\t\twithCredentials: false\n\t});\n\tvar url = this.endpoint + '/' + this.appName + '/config.get';\n\tvar data = {\n\t\tbaseUrl: this.endpoint,\n\t\tappName: this.appName\n\t};\n\n\tdata = '[]\\n' + JSON.stringify(data);\n\n\thr.send('POST', url, {}, data, null, function (err, res) {\n\t\tif (err) {\n\t\t\treturn cb(new MageConfigureError(err));\n\t\t}\n\n\t\tvar resData = res[0];\n\t\tvar errMsg = resData[0];\n\t\tif (errMsg) {\n\t\t\treturn cb(new MageConfigureError(errMsg));\n\t\t}\n\n\t\tthat.setup(resData[1], cb);\n\t});\n};\n\nMage.prototype.setEndpoint = function (endpoint, appName) {\n\tif (!appName) {\n\t\tappName = 'game';\n\t}\n\n\tthis.endpoint = endpoint;\n\tthis.appName = appName;\n};\n\nMage.prototype.getClientHostBaseUrl = function () {\n\treturn this.clientHostBaseUrl;\n};\n\n\nMage.prototype.getSavvyBaseUrl = function (protocol) {\n\tvar baseUrl = this.savvyBaseUrl;\n\tif (!baseUrl) {\n\t\tbaseUrl = '/savvy';\n\t}\n\n\tif (baseUrl[0] === '/') {\n\t\t// location.origin is perfect for this, but badly supported\n\n\t\tbaseUrl = this.savvyBaseUrl = window.location.protocol + '//' + window.location.host + baseUrl;\n\n\t\tconsole.warn('No savvy base URL configured, defaulting to:', baseUrl, '(which may not work)');\n\t}\n\n\tif (protocol) {\n\t\t// drop any trailing colons and slashes\n\n\t\tprotocol = protocol.replace(/:?\\/*$/, '');\n\n\t\treturn baseUrl.replace(/^.*:\\/\\//, protocol + '://');\n\t}\n\n\treturn baseUrl;\n};\n\n\n// expose configuration set up\n// mage.configure registers the configuration and emits 'configure'\n\nMage.prototype.setup = function (config, cb) {\n\tif (!config) {\n\t\treturn cb(new Error('Mage requires a configuration to be instantiated.'));\n\t}\n\n\tthis.config = config;\n\n\tthis.appName = config.appName;\n\tthis.appVersion = config.appVersion;\n\n\t// set up server connections\n\n\tthis.clientHostBaseUrl = config.baseUrl || this.endpoint;\n\n\tvar server = config.server || {};\n\n\tthis.savvyBaseUrl = server.savvy ? server.savvy.url : ''; // TODO: what about server.savvy.cors?\n\n\tif (server.commandCenter) {\n\t\tthis.commandCenter.setupCommandSystem(server.commandCenter);\n\t\tthis.setupCommandsModules(server.commandCenter.commands, function (err) {\n\t\t\tif (err) {\n\t\t\t\treturn cb(err);\n\t\t\t}\n\t\t});\n\t}\n\n\tif (this.msgServer.setupMessageStream(server.msgStream)) {\n\t\tvar that = this;\n\n\t\tif (this.session) {\n\t\t\t// Session module is created, set up the event listeners:\n\n\t\t\t// When a session key is available or changes, set the key and (re)start the message stream.\n\t\t\tthis.eventManager.on('session.set', function (path, session) {\n\t\t\t\tthat.msgServer.setSessionKey(session.key);\n\t\t\t\tthat.msgServer.start();\n\t\t\t});\n\n\t\t\t// When a session key expires, stop the message stream.\n\t\t\tthis.eventManager.on('session.unset', function () {\n\t\t\t\tthat.msgServer.abort();\n\t\t\t});\n\t\t}\n\t}\n\n\treturn cb(null);\n};\n\nMage.prototype.isDevelopmentMode = function () {\n\treturn this.config.developmentMode;\n};\n\n\n// The MAGE module system\n\nvar modules = {};\n\nMage.prototype.isConfigured = function () {\n\treturn !!this.config;\n};\n\n// Call setup function from the given module\n\nMage.prototype.setupModule = function (name, mod) {\n\tmod = mod || {};\n\tvar that = this;\n\n\treturn new Promise(function (resolve, reject) {\n\t\tif (!that.isConfigured()) {\n\t\t\treturn reject(new MageNotConfiguredError());\n\t\t}\n\n\t\tif (!modules.hasOwnProperty(name)) {\n\t\t\treturn reject(new Error('Cannot configure module ' + name + '. This module has not been loaded'));\n\t\t}\n\n\t\tmodules[name] = that[name] = Object.assign(mod, that[name]);\n\n\t\tif (!mod.hasOwnProperty('setup')) {\n\t\t\tthat.emit('setup.' + name, mod);\n\t\t\treturn resolve(mod);\n\t\t}\n\n\t\tmod.setup(function (error) {\n\t\t\tif (error) {\n\t\t\t\treturn reject(error);\n\t\t\t}\n\n\t\t\tthat.emit('setup.' + name, mod);\n\t\t\treturn resolve(mod);\n\t\t});\n\t});\n};\n\nMage.prototype.getModule = function (name) {\n\treturn this.modules[name];\n};\n\nfunction createUserCommand(commandCenter, modName, cmdName, params) {\n\t// function name (camelCase)\n\n\tvar fnName = modName + cmdName[0].toUpperCase() + cmdName.slice(1);\n\n\t// function arguments\n\n\tparams = params.concat('cb');\n\n\tvar args = params.join(', ');\n\n\t// expected use\n\n\tvar expected = modName + '.' + cmdName + '(' + args + ')';\n\n\t// real use\n\n\t// eslint-disable-next-line no-unused-vars\n\tfunction serializeActualUse(args) {\n\t\tvar result = [];\n\n\t\tfor (var i = 0; i < args.length; i += 1) {\n\t\t\tvar arg = args[i];\n\n\t\t\tif (typeof arg === 'function') {\n\t\t\t\targ = 'Function';\n\t\t\t} else {\n\t\t\t\targ = JSON.stringify(arg);\n\t\t\t}\n\n\t\t\tresult.push(arg);\n\t\t}\n\n\t\treturn modName + '.' + cmdName + '(' + result.join(', ') + ')';\n\t}\n\n\t// function body\n\n\tvar body = [];\n\n\tbody.push('fn = function ' + fnName + '(' + args + ') {');\n\tbody.push('\\tvar params = {');\n\n\tfor (var i = 0; i < params.length; i += 1) {\n\t\tbody.push('\\t\\t' + params[i] + ': ' + params[i] + (i < params.length - 1 ? ',' : ''));\n\t}\n\n\tbody.push('\\t};');\n\tbody.push('');\n\tbody.push('\\ttry {');\n\tbody.push('\\t\\treturn commandCenter.sendCommand(' + JSON.stringify(modName + '.' + cmdName) + ', params, cb);');\n\tbody.push('\\t} catch (error) {');\n\tbody.push('\\t\\tconsole.warn(' + JSON.stringify('Expected use: ' + expected) + ');');\n\tbody.push('\\t\\tconsole.warn(\"Actual use: \" + serializeActualUse(arguments));');\n\tbody.push('\\t\\tthrow error;');\n\tbody.push('\\t};');\n\tbody.push('};');\n\n\tbody = body.join('\\n');\n\n\tvar fn;\n\n\ttry {\n\t\t// eslint-disable-next-line no-eval\n\t\teval(body);\n\t} catch (e) {\n\t\tconsole.error('Error generating usercommand:', modName + '.' + cmdName);\n\t\tthrow e;\n\t}\n\n\treturn fn;\n}\n\n// Load all commands from a module\n//\n// It will:\n// 1) Add a module object in the Mage instance\n// 2) Add a function for each command in the module object\n//\n// Ex: command list in module player would add mage.player.list\n\nfunction initModule(mage, name, cb) {\n\tif (!mage.isConfigured()) {\n\t\treturn cb(new MageNotConfiguredError());\n\t} else if (mage[name]) {\n\t\treturn cb(new Error('Cannot register module \"' + name + '\". This is a reserved name.'));\n\t}\n\n\tvar mod = {};\n\tmodules[name] = mage[name] = mod;\n\n\tvar commands = mage.config.server.commandCenter.commands[name];\n\n\tif (commands && commands.length > 0) {\n\t\tfor (var j = 0; j < commands.length; j += 1) {\n\t\t\tvar cmd = commands[j];\n\n\t\t\tmod[cmd.name] = createUserCommand(mage.commandCenter, name, cmd.name, cmd.params || []);\n\t\t}\n\t}\n\n\tmage.emit('created.' + name, mod);\n\n\treturn cb(null);\n}\n\n// Load all commands from client config\n\nMage.prototype.setupCommandsModules = function (modules, cb) {\n\tif (!modules) {\n\t\treturn;\n\t}\n\n\tvar modulesNames = Object.keys(modules);\n\tfor (var i = 0; i < modulesNames.length; i += 1) {\n\t\tvar moduleName = modulesNames[i];\n\t\tif (this[moduleName]) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tinitModule(this, moduleName, cb);\n\t}\n};\n","var msgStream = require('./messageStream');\n\n\nfunction MsgServer(eventManager) {\n\tthis.futureLog = {};\t// queues up events for soon or immediate emission\n\tthis.expectedMsgId = null;\n\tthis.stream = null;\n\tthis.sessionKey = null;\n\n\tthis.eventManager = eventManager;\n}\n\nmodule.exports = MsgServer;\n\n\n/**\n * Queues up messages for later emission\n * @param {Object} messages\n */\n\nMsgServer.prototype.addMessages = function (messages) {\n\tif (!messages) {\n\t\treturn;\n\t}\n\n\tif (typeof messages !== 'object') {\n\t\tthrow new TypeError('Messages passed must be an object');\n\t}\n\n\tvar msgIds = Object.keys(messages);\n\n\tfor (var i = 0; i < msgIds.length; i += 1) {\n\t\tvar msgId = msgIds[i];\n\t\tvar msgIdNum = parseInt(msgId, 10);\n\n\t\t// register the message into the futureLog for later emission\n\n\t\tthis.futureLog[msgId] = messages[msgId];\n\n\t\t// tell the message stream it may confirm this message as delivered\n\n\t\tif (this.stream && this.stream.confirm) {\n\t\t\tthis.stream.confirm(msgId);\n\t\t}\n\n\t\t// make sure we are expecting the lowest possible msgId first\n\n\t\tif (msgIdNum !== 0 && (this.expectedMsgId === null || msgIdNum < this.expectedMsgId)) {\n\t\t\tthis.expectedMsgId = msgIdNum;\n\t\t}\n\t}\n};\n\n\n/**\n * Forgets about all currently registered messages. Required after a session key change.\n */\n\nMsgServer.prototype.resetFutureLog = function () {\n\tthis.expectedMsgId = null;\n\tthis.futureLog = {};\n};\n\n\nMsgServer.prototype.emitEvents = function (msgId) {\n\tvar messages = this.futureLog[msgId];\n\n\tdelete this.futureLog[msgId];\n\n\t// Emit the events in the message pack.\n\n\tif (messages) {\n\t\tthis.eventManager.emitEvents(messages);\n\t}\n};\n\n\n/**\n * Emits as many messages as can be emitted without creating gaps in the flow of msgId keys\n */\n\nMsgServer.prototype.emitFutureLog = function () {\n\t// Keep emitting until we encounter a gap, or futureLog has simply gone empty\n\n\twhile (this.expectedMsgId && this.futureLog.hasOwnProperty(this.expectedMsgId)) {\n\t\t// Early increment expectedMsgId, so that even if an event listener were to throw, the next\n\t\t// time we call emitFutureLog, we know that we won't be expecting an old ID.\n\n\t\tvar msgId = this.expectedMsgId;\n\n\t\tthis.expectedMsgId += 1;\n\n\t\tthis.emitEvents(msgId);\n\t}\n\n\t// finally emit any events that don't have an ID and thus don't need confirmation and lack order\n\n\tif (this.futureLog.hasOwnProperty('0')) {\n\t\tthis.emitEvents('0');\n\t}\n};\n\n\n/**\n * Kills the stream connection. Can be resumed later by calling start().\n */\n\nMsgServer.prototype.abort = function () {\n\tif (this.stream) {\n\t\tthis.stream.abort();\n\t}\n};\n\n\n/**\n * Starts or resumes (after abort() had been called) the stream connection.\n */\n\nMsgServer.prototype.start = function () {\n\tif (!this.stream) {\n\t\tthrow new Error('The message stream has not yet been set up');\n\t}\n\n\tthis.stream.start();\n};\n\n\n/**\n * Configures the message stream's transport types\n *\n * @param {Object} cfg\n * @return {boolean}       Returns true if succeeded to set up a transport, false otherwise.\n */\n\nMsgServer.prototype.setupMessageStream = function (cfg) {\n\tif (!cfg) {\n\t\treturn false;\n\t}\n\n\tvar that = this;\n\tvar confirmIds = [];\n\n\t// instantiate the event stream if needed\n\n\tif (this.stream) {\n\t\tconfirmIds = this.stream.getUnconfirmed();\n\n\t\tthis.stream.destroy();\n\t\tthis.stream = null;\n\t}\n\n\tvar stream = msgStream.create(cfg);\n\tif (!stream) {\n\t\treturn false;\n\t}\n\n\tstream.on('error', function (error) {\n\t\tconsole.warn('Error from message stream transport:', error);\n\t});\n\n\tstream.on('delivery', function (messages) {\n\t\ttry {\n\t\t\tthat.addMessages(messages);\n\t\t\tthat.emitFutureLog();\n\t\t} catch (error) {\n\t\t\tconsole.error('Error during message stream event emission:', error);\n\t\t}\n\t});\n\n\tif (this.sessionKey) {\n\t\tstream.setSessionKey(this.sessionKey);\n\t}\n\n\tfor (var i = 0; i < confirmIds.length; i += 1) {\n\t\tstream.confirm(confirmIds[i]);\n\t}\n\n\tthis.stream = stream;\n\n\treturn true;\n};\n\n\nMsgServer.prototype.setSessionKey = function (sessionKey) {\n\tif (!this.stream) {\n\t\tthrow new Error('The message stream has not yet been set up');\n\t}\n\n\t// Make sure any lingering messages are wiped out\n\n\tif (sessionKey !== this.sessionKey) {\n\t\tthis.resetFutureLog();\n\t\tthis.sessionKey = sessionKey;\n\t}\n\n\tthis.stream.setSessionKey(sessionKey);\n};\n\n","var HttpRequest = require('../HttpRequest');\nvar EventEmitter = require('events.js');\nvar inherits = require('inherits');\n\n\nfunction HttpPollingClient(style, cfg) {\n\tEventEmitter.call(this);\n\n\tvar that = this;\n\n\tvar hr = new HttpRequest({\n\t\tnoCache: true,\n\t\twithCredentials: cfg.cors && cfg.cors.credentials ? true : false\n\t});\n\n\tvar lastError;\n\tvar endpoint = cfg.url;\n\tvar confirmIds = [];\n\tvar sessionKey;\n\n\tvar afterRequestInterval = cfg.afterRequestInterval || (style === 'shortpolling' ? 5000 : 0);\n\tvar afterErrorInterval = cfg.afterErrorInterval || 5000;\n\n\tthis.isRunning = false;\n\n\tvar send;\n\n\n\tfunction scheduleNext() {\n\t\tif (!that.isRunning) {\n\t\t\t// nothing to schedule if we've been aborted\n\t\t\treturn;\n\t\t}\n\n\t\tif (lastError) {\n\t\t\tsetTimeout(send, afterErrorInterval);\n\t\t} else {\n\t\t\tsetTimeout(send, afterRequestInterval);\n\t\t}\n\t}\n\n\n\tfunction ondone(error, response) {\n\t\tif (error) {\n\t\t\tlastError = error;\n\n\t\t\tthat.emit('error', { error: error, data: response });\n\t\t} else {\n\t\t\tconfirmIds = [];\n\n\t\t\tif (response !== null && typeof response === 'object') {\n\t\t\t\tthat.emit('delivery', response);\n\t\t\t}\n\t\t}\n\n\t\tscheduleNext();\n\t}\n\n\n\tsend = function () {\n\t\tif (!that.isRunning) {\n\t\t\treturn;\n\t\t}\n\n\t\tlastError = null;\n\n\t\tvar params = {\n\t\t\ttransport: style\n\t\t};\n\n\t\tif (sessionKey) {\n\t\t\tparams.sessionKey = sessionKey;\n\t\t}\n\n\t\tif (confirmIds.length > 0) {\n\t\t\tparams.confirmIds = confirmIds.join(',');\n\t\t}\n\n\t\t// send the request\n\n\t\thr.send('GET', endpoint, params, null, null, ondone);\n\t};\n\n\n\tthis.setSessionKey = function (key) {\n\t\tsessionKey = key;\n\t};\n\n\n\tthis.start = function () {\n\t\tif (this.isRunning) {\n\t\t\t// restart, since setup has probably changed\n\n\t\t\thr.abort();\n\n\t\t\tsetTimeout(function () {\n\t\t\t\tsend();\n\t\t\t}, 0);\n\t\t} else {\n\t\t\tthis.isRunning = true;\n\n\t\t\tsend();\n\t\t}\n\n\n\t\treturn true;\n\t};\n\n\n\tthis.confirm = function (msgId) {\n\t\tconfirmIds.push(msgId);\n\t};\n\n\n\tthis.getUnconfirmed = function () {\n\t\treturn confirmIds.slice();\n\t};\n\n\n\tthis.abort = function () {\n\t\thr.abort();\n\t\tthis.isRunning = false;\n\t};\n\n\n\tthis.destroy = function () {\n\t\tthis.abort();\n\t\tthis.removeAllListeners();\n\t};\n}\n\ninherits(HttpPollingClient, EventEmitter);\n\n\nexports.longpolling = {\n\ttest: function (cfg) {\n\t\treturn cfg.url ? true : false;\n\t},\n\tcreate: function (cfg) {\n\t\treturn new HttpPollingClient('longpolling', cfg);\n\t}\n};\n\nexports.shortpolling = {\n\ttest: function (cfg) {\n\t\treturn cfg.url ? true : false;\n\t},\n\tcreate: function (cfg) {\n\t\treturn new HttpPollingClient('shortpolling', cfg);\n\t}\n};\n","var transports = {\n\tlongpolling: require('./http').longpolling,\n\tshortpolling: require('./http').shortpolling,\n\twebsocket: require('./ws')\n};\n\n\nexports.transports = transports;\n\n\n/**\n * Creates a stream over which we can receive messages asynchronously\n *\n * @param {Object} config     Configuration for the message stream system\n * @returns {Object}          The stream instance, or undefined if none is usable\n */\n\nexports.create = function (config) {\n\tvar detect = config.detect || [];\n\n\tfor (var i = 0; i < detect.length; i += 1) {\n\t\tvar type = detect[i];\n\t\tvar cfg = config.transports[type] || {};\n\n\t\tvar transport = transports[type];\n\n\t\tif (!transport) {\n\t\t\tconsole.log('Unrecognized transport type:', type, '(skipping)');\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (transport.test(cfg)) {\n\t\t\treturn transport.create(cfg);\n\t\t}\n\t}\n\n\tconsole.warn('Could not create any transport out of:', detect);\n};\n\n","var EventEmitter = require('events.js');\nvar inherits = require('inherits');\n\n\nfunction normalizeWsUrl(str) {\n\tif (str.indexOf('http') === -1) {\n\t\t// trim left slash from str\n\n\t\tif (str[0] !== '/') {\n\t\t\tstr = '/' + str;\n\t\t}\n\n\t\t// make a full URL\n\n\t\tvar location = window.location;\n\n\t\tstr = location.protocol + '//' + location.host + str;  // host includes port\n\t}\n\n\t// switch protocols\n\treturn str.replace(/^http/, 'ws');\n}\n\n\nfunction WebSocketClient(cfg) {\n\tEventEmitter.call(this);\n\n\tvar that = this;\n\tvar ws = null;\n\tvar isOpen = false;\n\tvar confirmIds = [];\n\n\tvar afterRequestInterval = cfg.afterRequestInterval || 100;\n\tvar afterErrorInterval = cfg.afterErrorInterval || 5000;\n\n\tvar endpoint = normalizeWsUrl(cfg.url);\n\tvar sessionKey;\n\n\n\tfunction attemptReconnect(interval) {\n\t\tsetTimeout(function () {\n\t\t\tthat.start();\n\t\t}, interval);\n\t}\n\n\n\tthis.setSessionKey = function (key) {\n\t\tsessionKey = key;\n\t};\n\n\n\tthis.start = function () {\n\t\t// restart, since setup has probably changed\n\n\t\tthis.abort();\n\n\t\ttry {\n\t\t\tvar url = endpoint;\n\t\t\tif (sessionKey) {\n\t\t\t\tif (url.indexOf('?') === -1) {\n\t\t\t\t\turl += '?sessionKey=' + encodeURIComponent(sessionKey);\n\t\t\t\t} else {\n\t\t\t\t\turl += '&sessionKey=' + encodeURIComponent(sessionKey);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tws = new window.WebSocket(url);\n\t\t} catch (error) {\n\t\t\t// see: https://developer.mozilla.org/en-US/docs/WebSockets/Writing_WebSocket_client_applications\n\t\t\tconsole.error('Possible security violation (aborting):', error);\n\t\t\treturn false;\n\t\t}\n\n\t\tws.onopen = function () {\n\t\t\tisOpen = true;\n\t\t};\n\n\t\tws.onmessage = function (evt) {\n\t\t\tvar msg = evt.data;\n\n\t\t\ttry {\n\t\t\t\tmsg = JSON.parse(msg);\n\t\t\t} catch (parseError) {\n\t\t\t\tthat.emit('error', parseError, msg);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tfor (var i = 0; i < confirmIds.length; i += 1) {\n\t\t\t\tvar id = confirmIds[i];\n\t\t\t\tif (msg[id]) {\n\t\t\t\t\tdelete msg[id];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthat.emit('delivery', msg);\n\t\t};\n\n\t\tws.onclose = function (evt) {\n\t\t\t// https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent\n\t\t\t// errors are >=1002\n\n\t\t\tisOpen = false;\n\t\t\tws = null;\n\n\t\t\tif (evt.code && evt.code >= 1002) {\n\t\t\t\tthat.emit('error', { error: evt.code, data: evt.reason });\n\n\t\t\t\tattemptReconnect(afterErrorInterval);\n\t\t\t} else {\n\t\t\t\tattemptReconnect(afterRequestInterval);\n\t\t\t}\n\t\t};\n\n\t\treturn true;\n\t};\n\n\n\tthis.confirm = function (msgId) {\n\t\tconfirmIds.push(msgId);\n\n\t\tif (ws && isOpen) {\n\t\t\tws.send(confirmIds.join(','));\n\t\t\tconfirmIds = [];\n\t\t}\n\t};\n\n\n\tthis.getUnconfirmed = function () {\n\t\treturn confirmIds.slice();\n\t};\n\n\n\tthis.abort = function () {\n\t\tif (ws) {\n\t\t\tws.onclose = null;\n\t\t\tws.close();\n\t\t\tws = null;\n\t\t}\n\n\t\tisOpen = false;\n\t};\n\n\n\tthis.destroy = function () {\n\t\tthis.abort();\n\t\tthis.removeAllListeners();\n\t};\n}\n\ninherits(WebSocketClient, EventEmitter);\n\n\nexports.test = function (cfg) {\n\treturn (cfg.url && window.WebSocket) ? true : false;\n};\n\nexports.create = function (cfg) {\n\treturn new WebSocketClient(cfg);\n};\n","function deepCopy(obj) {\n\tif (!obj) {\n\t\treturn obj;\n\t}\n\n\tif (obj instanceof Date) {\n\t\treturn obj;\n\t}\n\n\tobj = obj.valueOf();\n\n\tvar out;\n\n\tif (Array.isArray(obj)) {\n\t\tvar len = obj.length;\n\n\t\tout = new Array(len);\n\n\t\tfor (var i = 0; i < len; i++) {\n\t\t\tout[i] = deepCopy(obj[i]);\n\t\t}\n\t} else if (typeof obj === 'object') {\n\t\tout = {};\n\n\t\tfor (var key in obj) {\n\t\t\tif (obj.hasOwnProperty(key)) {\n\t\t\t\tout[key] = deepCopy(obj[key]);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tout = obj;\n\t}\n\n\treturn out;\n}\n\nmodule.exports = deepCopy;\n"],"sourceRoot":""}